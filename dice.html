<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>3D 摇骰子</title>
    <!-- 引入云字体 -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Ma+Shan+Zheng&text=發&display=swap" rel="stylesheet">
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/RoundedBoxGeometry.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505; 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
            display: flex; flex-direction: column; justify-content: flex-end; 
            padding-bottom: 32px; 
            box-sizing: border-box;
            z-index: 10;
        }
        #confetti-canvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 100;
        }

        /* --- 统一的 UI 材质系统 --- */
        .glass-panel {
            background: rgba(30, 30, 30, 0.6); 
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.25);
            color: rgba(255, 255, 255, 0.95);
            transition: transform 0.1s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s ease;
        }

        /* 底部工具栏容器 */
        .footer-bar {
            position: relative;
            width: 100%;
            display: flex;
            justify-content: center; 
            align-items: center;     
            pointer-events: none;
            height: 56px; 
        }

        /* 引导文字 */
        .instruction {
            font-size: 16px; 
            font-weight: 400; 
            padding: 0 20px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            letter-spacing: 1px;
            border-radius: 24px; 
            text-shadow: none;
            
            /* 交互属性 */
            pointer-events: auto; 
            cursor: pointer;
            user-select: none;
        }

        /* [关键修复] 让文字内容本身不响应鼠标事件，确保点击穿透到父容器 div 上 */
        .instruction span {
            pointer-events: none;
        }
        
        /* 设置按钮 */
        #settings-btn {
            position: absolute; 
            left: 24px;
            top: 50%;
            transform: translateY(-50%);
            width: 48px; height: 48px; 
            border-radius: 50%; 
            appearance: none;
            outline: none;
            cursor: pointer; 
            pointer-events: auto;
            display: flex; justify-content: center; align-items: center;
            
            background: transparent;
            color: rgba(255, 255, 255, 0.8);
            border: none;
            filter: drop-shadow(0 4px 6px rgba(0,0,0,0.5));
            
            transition: transform 0.1s, color 0.2s;
        }
        #settings-btn:active { 
            transform: translateY(-50%) scale(0.92); 
            color: #fff;
            background: transparent; 
        }
        
        /* 游戏面板 & 设置面板 */
        #game-panel {
            display: flex; width: 100%; justify-content: center; align-items: center;
            transition: opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1), transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
        }
        #game-panel.hidden { opacity: 0; transform: translateY(20px); pointer-events: none; }

        #settings-panel {
            position: absolute; left: 0; top: 0; width: 100%; height: 100%;
            display: flex; justify-content: center; align-items: center; gap: 16px;
            opacity: 0; pointer-events: none;
            transform: translateY(20px);
            transition: opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1), transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        #settings-panel.show { opacity: 1; transform: translateY(0); pointer-events: auto; }

        /* 数量控制组 */
        .control-group {
            display: flex; align-items: center; 
            height: 48px;
            border-radius: 24px;
            padding: 0 8px;
            pointer-events: auto;
            gap: 0; 
        }

        /* 控制按钮 */
        .btn-icon {
            width: 36px; height: 36px; 
            border-radius: 50%; 
            border: none;
            background: transparent; 
            color: rgba(255, 255, 255, 0.8);
            cursor: pointer;
            display: flex; justify-content: center; align-items: center;
            transition: all 0.2s;
            padding: 0;
        }
        .btn-icon:active { 
            background: rgba(255, 255, 255, 0.15); 
            color: #fff;
            transform: scale(0.9);
        }
        
        #setting-dice-count {
            font-size: 22px; 
            font-weight: 600; 
            color: #fff; 
            width: 40px; 
            text-align: center;
            font-family: 'Helvetica Neue', sans-serif;
            font-variant-numeric: tabular-nums; 
        }

        /* 确认按钮 */
        .btn-check {
            width: 48px; height: 48px; 
            border-radius: 50%; 
            border: none;
            background: linear-gradient(135deg, #ff2200 0%, #cc1500 100%);
            color: white;
            cursor: pointer;
            display: flex; justify-content: center; align-items: center;
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.3);
            transition: transform 0.1s cubic-bezier(0.4, 0, 0.2, 1);
            pointer-events: auto;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .btn-check:active { 
            transform: scale(0.92); 
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.2);
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <canvas id="confetti-canvas"></canvas>
    
    <div id="ui-layer">
        <div class="footer-bar">
            <!-- 游戏面板 -->
            <div id="game-panel">
                <button id="settings-btn" onclick="enterSettings()">
                    <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="3"></circle>
                        <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
                    </svg>
                </button>
                <!-- [关键修复] 将文字包裹在 span 中 -->
                <div id="status-text" class="instruction glass-panel"><span>点击骰盅摇骰子</span></div>
            </div>

            <!-- 设置面板 -->
            <div id="settings-panel">
                <div class="control-group glass-panel">
                    <button class="btn-icon" onclick="adjustDice(-1)">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="5" y1="12" x2="19" y2="12"></line>
                        </svg>
                    </button>
                    <span id="setting-dice-count">5</span>
                    <button class="btn-icon" onclick="adjustDice(1)">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="12" y1="5" x2="12" y2="19"></line>
                            <line x1="5" y1="12" x2="19" y2="12"></line>
                        </svg>
                    </button>
                </div>
                <button class="btn-check" onclick="confirmSettings()">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="20 6 9 17 4 12"></polyline>
                    </svg>
                </button>
            </div>
        </div>
    </div>

    <script>
        // --- 佛光普照特效管理器 ---
        const LightRayManager = {
            canvas: null, ctx: null, 
            sparkleTexture: null, 
            coreTexture: null, 
            isActive: false, rotation: 0, opacity: 0, scale: 1, state: 'hidden', activeTimer: 0, 
            sparkles: [], 
            
            init: function() {
                this.canvas = document.getElementById('confetti-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.createSparkleTexture(); 
                this.createCoreTexture(); 
                this.resize();
                window.addEventListener('resize', () => this.resize());
            },
            
            createSparkleTexture: function() {
                const size = 32;
                const canvas = document.createElement('canvas');
                canvas.width = size; canvas.height = size;
                const ctx = canvas.getContext('2d');
                const cx = size / 2; const cy = size / 2;

                const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, size / 2);
                grad.addColorStop(0, 'rgba(255, 255, 255, 1)');
                grad.addColorStop(0.3, 'rgba(255, 220, 100, 0.8)');
                grad.addColorStop(1, 'rgba(255, 220, 100, 0)');

                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, size, size);
                this.sparkleTexture = canvas;
            },

            // Core 纹理生成
            createCoreTexture: function() {
                const size = 512;
                const canvas = document.createElement('canvas');
                canvas.width = size; canvas.height = size;
                const ctx = canvas.getContext('2d');
                const cx = size / 2; const cy = size / 2;

                const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, size / 2);
                grad.addColorStop(0.0, 'rgba(255, 255, 255, 0)'); 
                grad.addColorStop(0.45, 'rgba(255, 255, 255, 0)'); // 大空洞
                // 降低贴图基础不透明度
                grad.addColorStop(0.65, 'rgba(255, 220, 100, 0.4)'); 
                grad.addColorStop(1.0, 'rgba(255, 255, 255, 0)');

                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, size, size);
                this.coreTexture = canvas;
            },

            resize: function() { this.canvas.width = window.innerWidth; this.canvas.height = window.innerHeight; },
            
            trigger: function() {
                this.isActive = true; this.state = 'fading_in'; this.opacity = 0; this.rotation = 0; this.scale = 0.5; this.activeTimer = 0;
                this.sparkles = []; 
                this.spawnSparkles(300); 
            },

            spawnSparkles: function(count) {
                for (let i = 0; i < count; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const initialRadius = 120 + Math.random() * 50; 
                    const life = 250 + Math.random() * 200; 

                    this.sparkles.push({
                        x: Math.cos(angle) * initialRadius,
                        y: Math.sin(angle) * initialRadius,
                        angle: angle, 
                        speed: 0.5 + Math.random() * 2.0, 
                        scale: 0.3 + Math.random() * 0.7, 
                        alphaConst: 0.5 + Math.random() * 0.5,
                        life: life,
                        maxLife: life 
                    });
                }
            },
            
            animate: function() {
                if (!this.isActive) return;
                const ctx = this.ctx; const w = this.canvas.width; const h = this.canvas.height; 
                const centerW = w / 2; const centerH = h / 2;
                
                ctx.clearRect(0, 0, w, h);
                
                if (this.state === 'fading_in') { 
                    // 极速淡入
                    this.opacity += 0.2; 
                    if (this.opacity >= 1) { this.opacity = 1; this.state = 'active'; } 
                }
                else if (this.state === 'active') { 
                    this.activeTimer++; 
                    
                    // 呼吸效果
                    this.scale = 1.0 + Math.sin(this.activeTimer * 0.04) * 0.03; 
                    
                    if (this.activeTimer > 500) { this.state = 'fading_out'; } 
                }
                else if (this.state === 'fading_out') { 
                    this.opacity -= 0.02; 
                    if (this.opacity <= 0) { this.opacity = 0; this.isActive = false; this.state = 'hidden'; return; } 
                }
                
                this.rotation += 0.002; 
                
                // --- 第一层：Core (爆炸冲击效果 - 极慢) ---
                ctx.save(); 
                ctx.translate(centerW, centerH); 
                
                if (this.coreTexture) {
                    ctx.globalCompositeOperation = 'screen'; 
                    
                    const t = this.activeTimer;
                    
                    // 爆发阶段时长 160 帧
                    const duration = 160;
                    const progress = Math.min(t / duration, 1.0);
                    const ease = 1 - Math.pow(1 - progress, 3);
                    
                    // 惯性漂移
                    const drift = t * 0.004;

                    const currentScale = 0.6 + (1.3 * ease) + drift;

                    // 淡入时长 20 帧
                    let coreAlpha = 0;
                    if (this.activeTimer < 20) {
                        coreAlpha = this.activeTimer / 20; 
                    } else if (this.activeTimer < 250) {
                        coreAlpha = 1.0; 
                    } else {
                        coreAlpha = Math.max(0, 1 - (this.activeTimer - 250) / 150);
                    }

                    if (coreAlpha > 0) {
                        ctx.save();
                        ctx.scale(currentScale, currentScale); 
                        ctx.globalAlpha = this.opacity * coreAlpha;
                        const coreSize = 440; 
                        ctx.drawImage(this.coreTexture, -coreSize/2, -coreSize/2, coreSize, coreSize);
                        ctx.restore();
                    }
                }
                
                ctx.restore(); 

                // --- 第二层：星光点点 (独立层) ---
                if (this.sparkleTexture && this.sparkles.length > 0) {
                    ctx.save();
                    ctx.translate(centerW, centerH);
                    ctx.globalCompositeOperation = 'lighter'; 
                    
                    for (let i = this.sparkles.length - 1; i >= 0; i--) {
                        let p = this.sparkles[i];
                        
                        p.x += Math.cos(p.angle) * p.speed;
                        p.y += Math.sin(p.angle) * p.speed;
                        p.life--;
                        if (p.life <= 0) {
                            this.sparkles.splice(i, 1);
                            continue;
                        }
                        const lifeRatio = p.life / p.maxLife;
                        let fadeAlpha = lifeRatio;
                        ctx.globalAlpha = this.opacity * p.alphaConst * fadeAlpha;
                        const size = 32 * p.scale;
                        ctx.drawImage(this.sparkleTexture, p.x - size/2, p.y - size/2, size, size);
                    }
                    ctx.restore();
                }
            }
        };

        // --- 极简柏林噪声 ---
        const Perlin = (function() {
            const p = new Uint8Array(512);
            const permutation = [151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];
            for (let i=0; i < 256 ; i++) p[256+i] = p[i] = permutation[i];
            function fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
            function lerp(t, a, b) { return a + t * (b - a); }
            function grad(hash, x, y, z) {
                const h = hash & 15; const u = h<8 ? x : y, v = h<4 ? y : h==12||h==14 ? x : z;
                return ((h&1) == 0 ? u : -u) + ((h&2) == 0 ? v : -v);
            }
            return {
                noise: function (x, y, z) {
                    const X = Math.floor(x) & 255, Y = Math.floor(y) & 255, Z = Math.floor(z) & 255;
                    x -= Math.floor(x); y -= Math.floor(y); z -= Math.floor(z);
                    const u = fade(x), v = fade(y), w = fade(z);
                    const A = p[X]+Y, AA = p[A]+Z, AB = p[A+1]+Z, B = p[X+1]+Y, BA = p[B]+Z, BB = p[B+1]+Z;
                    return lerp(w, lerp(v, lerp(u, grad(p[AA], x, y, z), grad(p[BA], x-1, y, z)),
                                   lerp(u, grad(p[AB], x, y-1, z), grad(p[BB], x-1, y-1, z))),
                           lerp(v, lerp(u, grad(p[AA+1], x, y, z-1), grad(p[BA+1], x-1, y, z-1)),
                                   lerp(u, grad(p[AB+1], x, y-1, z-1), grad(p[BB+1], x-1, y-1, z-1))));
                }
            };
        })();

        // --- 音效管理器 ---
        const SoundManager = {
            ctx: null, noiseBuffer: null,
            init: function() {
                if (!this.ctx) {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    this.ctx = new AudioContext();
                    this.createNoiseBuffer();
                }
                if (this.ctx.state === 'suspended') this.ctx.resume();
            },
            createNoiseBuffer: function() {
                const bufferSize = this.ctx.sampleRate * 2;
                this.noiseBuffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = this.noiseBuffer.getChannelData(0);
                let lastOut = 0;
                for (let i = 0; i < bufferSize; i++) {
                    const white = Math.random() * 2 - 1;
                    data[i] = (lastOut + (0.05 * white)) / 1.05;
                    lastOut = data[i];
                    data[i] *= 3.5; 
                }
            },
            // UI 操作音效 (增加/减少)
            playUI: function(type) {
                if (!this.ctx) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sine';
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                
                if (type === 'add') {
                    osc.frequency.setValueAtTime(880, t);
                    osc.frequency.exponentialRampToValueAtTime(1200, t + 0.08);
                    gain.gain.setValueAtTime(0.1, t); 
                    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.08);
                    osc.start(t); osc.stop(t + 0.08);
                } else {
                    osc.frequency.setValueAtTime(440, t);
                    osc.frequency.exponentialRampToValueAtTime(300, t + 0.08);
                    gain.gain.setValueAtTime(0.1, t); 
                    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.08);
                    osc.start(t); osc.stop(t + 0.08);
                }
            },
            // [重构] 摇骰子：温润、沉稳、不刺耳
            playShake: function() {
                if (!this.ctx || !this.noiseBuffer) return;
                const t = this.ctx.currentTime;
                
                const hits = 5 + Math.floor(Math.random() * 4);
                
                const masterGain = this.ctx.createGain();
                masterGain.gain.value = 0.5; 
                masterGain.connect(this.ctx.destination);

                for(let i=0; i<hits; i++) {
                    const offset = Math.random() * 0.1;
                    
                    const source = this.ctx.createBufferSource();
                    source.buffer = this.noiseBuffer;
                    
                    const filter = this.ctx.createBiquadFilter();
                    
                    filter.type = 'bandpass'; 
                    filter.frequency.value = 400 + Math.random() * 800; 
                    filter.Q.value = 1.5; 
                    
                    const gain = this.ctx.createGain();
                    gain.gain.setValueAtTime(0, t + offset);
                    gain.gain.linearRampToValueAtTime(0.5 + Math.random() * 0.3, t + offset + 0.005); 
                    gain.gain.exponentialRampToValueAtTime(0.01, t + offset + 0.05);
                    
                    source.connect(filter); 
                    filter.connect(gain); 
                    gain.connect(masterGain); 
                    source.start(t + offset); 
                    source.stop(t + offset + 0.08);
                }
            },
            // 关闭声音
            playClose: function() {
                if (!this.ctx || !this.noiseBuffer) return;
                const t = this.ctx.currentTime;
                
                const osc = this.ctx.createOscillator();
                const oscGain = this.ctx.createGain();
                osc.frequency.setValueAtTime(100, t); osc.frequency.exponentialRampToValueAtTime(30, t + 0.15);
                oscGain.gain.setValueAtTime(0.2, t); oscGain.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
                osc.connect(oscGain); oscGain.connect(this.ctx.destination);
                osc.start(t); osc.stop(t + 0.2);
                
                const source = this.ctx.createBufferSource();
                source.buffer = this.noiseBuffer;
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass'; filter.frequency.value = 500;
                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0.3, t); gain.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
                source.connect(filter); filter.connect(gain); gain.connect(this.ctx.destination);
                source.start(t); source.stop(t + 0.15);
            },
            // [重构] 揭开声音：微弱、细腻的风声
            playOpen: function() {
                if (!this.ctx || !this.noiseBuffer) return;
                const t = this.ctx.currentTime;
                
                const source = this.ctx.createBufferSource();
                source.buffer = this.noiseBuffer;
                
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass'; 
                filter.Q.value = 0.5; // 非常平滑，无共振
                
                // [修改] 频率扫描范围降低 (200 -> 1200)，去掉了高频的"嘶"声，只保留"呼"声
                filter.frequency.setValueAtTime(200, t);
                filter.frequency.exponentialRampToValueAtTime(1200, t + 0.2); 
                
                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0, t);
                // [修改] 大幅降低音量 (0.8 -> 0.15)，变成背景音
                gain.gain.linearRampToValueAtTime(0.15, t + 0.05); 
                gain.gain.linearRampToValueAtTime(0, t + 0.25); 
                
                source.connect(filter); filter.connect(gain); gain.connect(this.ctx.destination);
                source.start(t); source.stop(t + 0.3);
            }
        };

        // --- 游戏变量 ---
        const GameState = { IDLE: 'IDLE', SHAKING: 'SHAKING', OPENED: 'OPENED', SETTINGS: 'SETTINGS' };
        let currentState = GameState.IDLE;
        let isCupAnimating = false; 
        let scene, camera, renderer;
        let diceArray = [];
        let dyingDiceArray = [];
        let cupMesh;
        let envMap; 
        let tableTextTexture;
        let tableTextCanvas;
        let currentDiceValues = []; 
        let currentDiceCount = 5;
        
        let nextCyclicValue = 1; 
        
        // 作弊相关变量
        let cheatClickCount = 0;
        let cheatClickTimer = null;
        let isCheatActive = false; 
        
        let hasTriggeredJackpot = false;

        let globalDiceGeometry;
        let globalDiceMaterials;

        let touchStartX = 0, touchStartY = 0, touchStartTime = 0;
        let isInteracting = false, isDragging = false, dragProgress = 0;   

        const TAP_THRESHOLD = 10; 
        const DRAG_FULL_DISTANCE = 250; 
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        const SHAKE_DURATION = 800; 
        const CUP_TARGET_OPEN = { y: 12, z: -4, rotX: -Math.PI / 4 };
        const CUP_TARGET_CLOSED = { y: 0, z: 0, rotX: 0 };
        
        const DICE_SIZE = 0.95; 
        const DICE_RADIUS = 0.18; 
        
        const CUP_HEIGHT = 7.0;       
        const CUP_RADIUS_TOP = 2.6;    
        const CUP_RADIUS_BOTTOM = 3.4;
        const CUP_RADIUS_OPEN = 3.4;
        const THICKNESS = 0.25;

        const LOOK_AT_FAR = new THREE.Vector3(0, 3, 0);   
        const CAM_POS_FAR = new THREE.Vector3(0, 14, 20); 
        const CAM_POS_CLOSE = new THREE.Vector3(0, 12, 4);  
        const LOOK_AT_CLOSE = new THREE.Vector3(0, 0.5, 0); 
        
        let currentCamPos = CAM_POS_FAR.clone();
        let currentLookAt = LOOK_AT_FAR.clone();

        window.enterSettings = function() {
            if (currentState !== GameState.IDLE && currentState !== GameState.OPENED) return;
            
            currentState = GameState.SETTINGS;
            document.getElementById('game-panel').classList.add('hidden');
            document.getElementById('settings-panel').classList.add('show');
            document.getElementById('setting-dice-count').innerText = currentDiceCount;
            
            if (dragProgress < 0.99) {
                SoundManager.playOpen();
                snapAnimation(1); 
            } else {
                dragProgress = 1;
                updateSceneFromProgress(1);
            }
        };

        window.adjustDice = function(delta) {
            let newCount = currentDiceCount + delta;
            if (newCount < 1) newCount = 1;
            if (newCount > 8) newCount = 8;
            if (newCount !== currentDiceCount) {
                if (delta > 0) SoundManager.playUI('add');
                else SoundManager.playUI('remove');

                updateDiceCount(newCount); 
                currentDiceCount = newCount;
                document.getElementById('setting-dice-count').innerText = currentDiceCount;
            }
        };

        window.confirmSettings = function() {
            snapAnimation(0); 
            document.getElementById('settings-panel').classList.remove('show');
            document.getElementById('game-panel').classList.remove('hidden');
        };

        init();
        animate();

        function init() {
            LightRayManager.init();
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);
            scene.fog = new THREE.Fog(0x111111, 10, 50);
            envMap = createStudioEnvMap();
            scene.environment = envMap;
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.copy(CAM_POS_FAR);
            camera.lookAt(LOOK_AT_FAR); 
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            maxAnisotropy = renderer.capabilities.getMaxAnisotropy();
            container.appendChild(renderer.domElement);
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
            dirLight.position.set(8, 15, 8); 
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.bias = -0.0001; 
            dirLight.shadow.camera.near = 0.5;
            dirLight.shadow.camera.far = 100; 
            dirLight.shadow.camera.left = -25; dirLight.shadow.camera.right = 25;
            dirLight.shadow.camera.top = 25; dirLight.shadow.camera.bottom = -25;
            scene.add(dirLight);
            const sideLight = new THREE.PointLight(0xffffff, 0.8, 50);
            sideLight.position.set(-10, 5, 10); 
            scene.add(sideLight);
            const frontLight = new THREE.DirectionalLight(0xffffff, 0.6);
            frontLight.position.set(0, 5, 10);
            scene.add(frontLight);
            const fillLight = new THREE.DirectionalLight(0xeef0ff, 0.3);
            fillLight.position.set(-5, 8, -5);
            scene.add(fillLight);
            initDiceResources();
            createFloor();
            createTableText(); 
            resetDice(currentDiceCount); 
            createCup(); 
            window.addEventListener('resize', onWindowResize);
            const canvas = renderer.domElement;
            canvas.addEventListener('touchstart', onInputStart, { passive: false });
            canvas.addEventListener('touchmove', onInputMove, { passive: false });
            canvas.addEventListener('touchend', onInputEnd, { passive: false });
            canvas.addEventListener('mousedown', onInputStart);
            window.addEventListener('mousemove', onInputMove); 
            window.addEventListener('mouseup', onInputEnd);
            document.fonts.ready.then(() => {
                if (tableTextCanvas && tableTextTexture) {
                    drawTableTextContent(tableTextCanvas.getContext('2d'), tableTextCanvas.width);
                    tableTextTexture.needsUpdate = true;
                }
            });
            setTimeout(() => { if(tableTextTexture) { drawTableTextContent(tableTextCanvas.getContext('2d'), 1024); tableTextTexture.needsUpdate = true; } }, 500);

            // [修改] 监听状态文字点击事件 (防作弊彩蛋)
            const statusTextEl = document.getElementById('status-text');
            if (statusTextEl) {
                statusTextEl.addEventListener('mousedown', onCheatClick);
                statusTextEl.addEventListener('touchstart', (e) => {
                    e.preventDefault(); // 防止双击缩放等干扰
                    onCheatClick(e);
                });
            }
        }

        // [修改] 彩蛋点击处理逻辑 - 无任何视觉反馈，修改阈值为 10
        function onCheatClick(e) {
            clearTimeout(cheatClickTimer);
            cheatClickCount++;
            
            cheatClickTimer = setTimeout(() => {
                cheatClickCount = 0;
            }, 1500);

            if (cheatClickCount === 10) {
                isCheatActive = true;
            } else if (cheatClickCount > 10) {
                if (isCheatActive) {
                    isCheatActive = false;
                }
            }
        }

        function createStudioEnvMap() {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 256; 
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#050505';
            ctx.fillRect(0, 0, 512, 256);
            const grad = ctx.createLinearGradient(0, 0, 0, 128);
            grad.addColorStop(0, '#ffffff');
            grad.addColorStop(1, '#000000');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, 512, 80);
            ctx.fillStyle = '#444444';
            ctx.fillRect(50, 100, 100, 50);
            ctx.fillStyle = '#333333';
            ctx.fillRect(350, 120, 80, 40);
            const texture = new THREE.CanvasTexture(canvas);
            texture.mapping = THREE.EquirectangularReflectionMapping; 
            return texture;
        }

        function createFeltTexture() {
            const canvas = document.createElement('canvas');
            const size = 1024; 
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#808080'; 
            ctx.fillRect(0, 0, size, size);
            const imageData = ctx.getImageData(0, 0, size, size);
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                const noise = (Math.random() - 0.5) * 100; 
                let val = 128 + noise;
                if (val < 0) val = 0; if (val > 255) val = 255;
                data[i] = val; data[i+1] = val; data[i+2] = val; data[i+3] = 255;
            }
            ctx.putImageData(imageData, 0, 0);
            ctx.filter = 'blur(4px)';
            ctx.drawImage(canvas, 0, 0);
            ctx.filter = 'none'; 
            const imageData2 = ctx.getImageData(0, 0, size, size);
            const data2 = imageData2.data;
            for (let i = 0; i < data2.length; i += 4) {
                const noise = (Math.random() - 0.5) * 20; 
                data2[i] += noise; data2[i+1] += noise; data2[i+2] += noise;
            }
            ctx.putImageData(imageData2, 0, 0);
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(2, 2); 
            texture.anisotropy = maxAnisotropy;
            texture.minFilter = THREE.LinearMipmapLinearFilter; 
            return texture;
        }

        function createFloor() {
            const geometry = new THREE.PlaneGeometry(100, 100);
            const feltTexture = createFeltTexture(); 
            const material = new THREE.MeshStandardMaterial({ 
                color: 0x0a3d18, roughness: 0.9, metalness: 0.0,
                bumpMap: feltTexture, bumpScale: 0.08, side: THREE.DoubleSide
            });
            floorMesh = new THREE.Mesh(geometry, material);
            floorMesh.rotation.x = -Math.PI / 2;
            floorMesh.receiveShadow = true;
            scene.add(floorMesh);
        }

        function drawTableTextContent(ctx, size) {
            const center = size / 2;
            ctx.clearRect(0, 0, size, size);
            const color = "#ffffff"; 
            ctx.strokeStyle = color; ctx.lineWidth = 30; 
            ctx.beginPath(); ctx.arc(center, center, 450, 0, Math.PI * 2); ctx.stroke();
            ctx.fillStyle = color; ctx.strokeStyle = color; ctx.lineWidth = 12; 
            ctx.font = "bold 650px 'Ma Shan Zheng', 'STKaiti', 'KaiTi', 'KaiTi_GB2312', 'FangSong', 'serif'"; 
            
            ctx.textAlign = "center"; 
            ctx.textBaseline = "alphabetic"; 
            ctx.lineJoin = 'round'; ctx.lineCap = 'round';
            
            const metrics = ctx.measureText("發");
            const ascent = metrics.actualBoundingBoxAscent;
            const descent = metrics.actualBoundingBoxDescent;
            const textX = center;
            const textY = center + (ascent - descent) / 2;
            
            ctx.strokeText("發", textX, textY); ctx.fillText("發", textX, textY);
            const imageData = ctx.getImageData(0, 0, size, size);
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                const alpha = data[i+3];
                if (alpha > 0) {
                    const x = (i / 4) % size;
                    const y = Math.floor((i / 4) / size);
                    const n = Perlin.noise(x * 0.2, y * 0.2, 5.5); 
                    if (alpha < 250) {
                        if (n < 0.2) data[i+3] = 0; else data[i+3] = 200; 
                    } else {
                        if (Math.random() > 0.98) data[i+3] = 50; 
                    }
                }
            }
            ctx.putImageData(imageData, 0, 0);
        }

        function createTableText() {
            tableTextCanvas = document.createElement('canvas');
            const size = 1024;
            tableTextCanvas.width = size; tableTextCanvas.height = size;
            drawTableTextContent(tableTextCanvas.getContext('2d'), size);
            tableTextTexture = new THREE.CanvasTexture(tableTextCanvas);
            tableTextTexture.minFilter = THREE.LinearMipmapLinearFilter;
            const geometry = new THREE.PlaneGeometry(5.0, 5.0); 
            const material = new THREE.MeshBasicMaterial({ 
                map: tableTextTexture, transparent: true, opacity: 0.3, 
                depthWrite: false, side: THREE.DoubleSide,
                alphaTest: 0.05
            });
            const textMesh = new THREE.Mesh(geometry, material);
            textMesh.rotation.x = -Math.PI / 2; textMesh.position.y = 0.015; 
            scene.add(textMesh);
        }

        function createDiceTexture(number) {
            const canvas = document.createElement('canvas');
            const size = 2048;
            canvas.width = size; canvas.height = size;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#eeeeee'; ctx.fillRect(0, 0, size, size);
            ctx.fillStyle = (number === 1 || number === 4) ? '#dd0000' : '#111111'; 
            let baseRadius = size / 11.6; 
            if (number === 1) baseRadius *= 1.5;
            const drawDot = (x, y) => {
                ctx.beginPath(); ctx.arc(x, y, baseRadius, 0, Math.PI * 2); ctx.fill();
            };
            const c = size / 2; const q = size / 4; const t = size * 3 / 4;
            if (number === 1) { drawDot(c, c); }
            else if (number === 2) { drawDot(q, q); drawDot(t, t); }
            else if (number === 3) { drawDot(q, q); drawDot(c, c); drawDot(t, t); }
            else if (number === 4) { drawDot(q, q); drawDot(t, q); drawDot(q, t); drawDot(t, t); }
            else if (number === 5) { drawDot(q, q); drawDot(t, q); drawDot(c, c); drawDot(q, t); drawDot(t, t); }
            else if (number === 6) { drawDot(q, q); drawDot(t, q); drawDot(q, c); drawDot(t, c); drawDot(q, t); drawDot(t, t); }
            const texture = new THREE.CanvasTexture(canvas);
            texture.anisotropy = renderer.capabilities.getMaxAnisotropy(); 
            texture.minFilter = THREE.LinearMipmapLinearFilter;
            texture.magFilter = THREE.LinearFilter;
            return texture;
        }

        function createDiceBumpMap(number) {
            const canvas = document.createElement('canvas');
            const size = 2048; canvas.width = size; canvas.height = size;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#ffffff'; ctx.fillRect(0, 0, size, size);
            ctx.fillStyle = '#000000'; ctx.shadowColor = '#000000'; ctx.shadowBlur = 20; 
            let baseRadius = size / 11.6; if (number === 1) baseRadius *= 1.5;
            const drawDot = (x, y) => {
                ctx.beginPath(); ctx.arc(x, y, baseRadius - 5, 0, Math.PI * 2); ctx.fill();
            };
            const c = size / 2; const q = size / 4; const t = size * 3 / 4;
            if (number === 1) { drawDot(c, c); }
            else if (number === 2) { drawDot(q, q); drawDot(t, t); }
            else if (number === 3) { drawDot(q, q); drawDot(c, c); drawDot(t, t); }
            else if (number === 4) { drawDot(q, q); drawDot(t, q); drawDot(q, t); drawDot(t, t); }
            else if (number === 5) { drawDot(q, q); drawDot(t, q); drawDot(c, c); drawDot(q, t); drawDot(t, t); }
            else if (number === 6) { drawDot(q, q); drawDot(t, q); drawDot(q, c); drawDot(t, c); drawDot(q, t); drawDot(t, t); }
            const texture = new THREE.CanvasTexture(canvas);
            texture.anisotropy = renderer.capabilities.getMaxAnisotropy(); 
            texture.minFilter = THREE.LinearMipmapLinearFilter;
            texture.magFilter = THREE.LinearFilter;
            return texture;
        }

        function initDiceResources() {
            globalDiceGeometry = new THREE.RoundedBoxGeometry(DICE_SIZE, DICE_SIZE, DICE_SIZE, 6, DICE_RADIUS);
            globalDiceMaterials = [];
            for (let i = 1; i <= 6; i++) {
                let num; if(i===1) num=1; else if(i===2) num=6; else if(i===3) num=2; else if(i===4) num=5; else if(i===5) num=3; else if(i===6) num=4;
                globalDiceMaterials.push(new THREE.MeshStandardMaterial({ 
                    map: createDiceTexture(num), bumpMap: createDiceBumpMap(num), bumpScale: 0.02, roughness: 0.2, metalness: 0.1 
                }));
            }
        }

        function getSafePosition() {
            const safeRadius = CUP_RADIUS_OPEN - 0.8;
            const minDistance = DICE_SIZE * 1.15;
            let position;
            let attempts = 0;
            const maxAttempts = 500;
            do {
                const angle = Math.random() * Math.PI * 2;
                const r = Math.sqrt(Math.random()) * safeRadius;
                position = new THREE.Vector3(Math.cos(angle) * r, DICE_SIZE / 2, Math.sin(angle) * r);
                let collision = false;
                for (let die of diceArray) {
                    if (die.position.distanceTo(position) < minDistance) { collision = true; break; }
                }
                if (!collision) return position;
                attempts++;
            } while (attempts < maxAttempts);
            return position; 
        }

        function addDie(forcedValue = null) {
            const dice = new THREE.Mesh(globalDiceGeometry, globalDiceMaterials);
            dice.castShadow = true; dice.receiveShadow = true;
            const pos = getSafePosition();
            dice.position.copy(pos);
            
            const value = forcedValue !== null ? forcedValue : (Math.floor(Math.random() * 6) + 1);
            
            dice.rotation.set(0, 0, 0); 
            switch(value) {
                case 1: dice.rotateZ(Math.PI / 2); break;
                case 6: dice.rotateZ(-Math.PI / 2); break;
                case 2: break; 
                case 5: dice.rotateX(Math.PI); break;
                case 3: dice.rotateX(-Math.PI / 2); break;
                case 4: dice.rotateX(Math.PI / 2); break;
            }
            dice.rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), Math.random() * Math.PI * 2);
            dice.scale.set(0, 0, 0); dice.userData.targetScale = 1; dice.userData.spawnTime = 0;
            diceArray.push(dice); scene.add(dice);
        }

        function removeDie() {
            if (diceArray.length === 0) return;
            const dice = diceArray.pop();
            dyingDiceArray.push({ mesh: dice, scale: 1.0 });
        }

        function updateDiceCount(targetCount) {
            const diff = targetCount - diceArray.length;
            if (diff > 0) { 
                for (let i = 0; i < diff; i++) {
                    addDie(nextCyclicValue);
                    nextCyclicValue = (nextCyclicValue % 6) + 1;
                } 
            } 
            else if (diff < 0) { for (let i = 0; i < Math.abs(diff); i++) removeDie(); }
        }

        function resetDice(count) {
            diceArray.forEach(d => scene.remove(d));
            diceArray = [];
            dyingDiceArray.forEach(d => scene.remove(d.mesh));
            dyingDiceArray = [];
            for (let i = 0; i < count; i++) addDie();
            diceArray.forEach(d => d.scale.set(1, 1, 1));
        }

        function createInjectionMarkMap() {
            const canvas = document.createElement('canvas');
            const size = 256;
            canvas.width = size; canvas.height = size;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#808080'; ctx.fillRect(0, 0, size, size);
            const center = size / 2;
            ctx.beginPath(); ctx.arc(center, center, 6, 0, Math.PI * 2); ctx.strokeStyle = '#606060'; ctx.lineWidth = 2; ctx.stroke();
            ctx.beginPath(); ctx.arc(center, center, 2, 0, Math.PI * 2); ctx.fillStyle = '#a0a0a0'; ctx.fill();
            return new THREE.CanvasTexture(canvas);
        }

        function createCup() {
            cupMesh = new THREE.Group();
            const matBlack = new THREE.MeshPhysicalMaterial({ 
                color: 0x050505, roughness: 0.15, metalness: 0.1, clearcoat: 1.0, clearcoatRoughness: 0.05, 
                envMap: envMap, envMapIntensity: 1.5, side: THREE.DoubleSide, bumpMap: createInjectionMarkMap(), bumpScale: 0.15
            });
            const matRed = new THREE.MeshPhysicalMaterial({
                color: 0xD40000, roughness: 0.25, metalness: 0.1, clearcoat: 1.0, clearcoatRoughness: 0.05,
                envMap: envMap, envMapIntensity: 1.2, side: THREE.DoubleSide
            });
            const height = CUP_HEIGHT; const rOpen = CUP_RADIUS_OPEN; const rBase = CUP_RADIUS_TOP; const thickness = 0.25; 
            const cornerRadius = 0.6; const bevelBottom = 0.2; const bevelSize = 0.05;   

            const outerPoints = [];
            outerPoints.push(new THREE.Vector2(rOpen - bevelSize, 0));
            const bottomCurve = new THREE.QuadraticBezierCurve(new THREE.Vector2(rOpen - bevelSize, 0), new THREE.Vector2(rOpen, 0), new THREE.Vector2(rOpen, bevelBottom));
            outerPoints.push(...bottomCurve.getPoints(12));
            const sideCurve = new THREE.QuadraticBezierCurve(new THREE.Vector2(rOpen, bevelBottom), new THREE.Vector2(rBase, height * 0.6), new THREE.Vector2(rBase, height - cornerRadius));
            outerPoints.push(...sideCurve.getPoints(32));
            const topCurve = new THREE.QuadraticBezierCurve(new THREE.Vector2(rBase, height - cornerRadius), new THREE.Vector2(rBase, height), new THREE.Vector2(rBase - cornerRadius, height));
            outerPoints.push(...topCurve.getPoints(12));
            outerPoints.push(new THREE.Vector2(0.2, height)); outerPoints.push(new THREE.Vector2(0, height - 0.05)); 
            const outerGeo = new THREE.LatheGeometry(outerPoints, 64);
            const outerMesh = new THREE.Mesh(outerGeo, matBlack);
            outerMesh.castShadow = true; outerMesh.receiveShadow = true; cupMesh.add(outerMesh);

            const innerPoints = [];
            innerPoints.push(new THREE.Vector2(rOpen - thickness - bevelSize, 0));
            const innerBottomCurve = new THREE.QuadraticBezierCurve(new THREE.Vector2(rOpen - thickness - bevelSize, 0), new THREE.Vector2(rOpen - thickness, 0), new THREE.Vector2(rOpen - thickness, bevelBottom));
            innerPoints.push(...innerBottomCurve.getPoints(12));
            const innerSideCurve = new THREE.QuadraticBezierCurve(new THREE.Vector2(rOpen - thickness, bevelBottom), new THREE.Vector2(rBase - thickness, height * 0.6), new THREE.Vector2(rBase - thickness, height - thickness - cornerRadius));
            innerPoints.push(...innerSideCurve.getPoints(32));
            const innerTopCurve = new THREE.QuadraticBezierCurve(new THREE.Vector2(rBase - thickness, height - thickness - cornerRadius), new THREE.Vector2(rBase - thickness, height - thickness), new THREE.Vector2(rBase - thickness - cornerRadius, height - thickness));
            innerPoints.push(...innerTopCurve.getPoints(12));
            innerPoints.push(new THREE.Vector2(0, height - thickness));
            const innerGeo = new THREE.LatheGeometry(innerPoints, 64);
            const innerMesh = new THREE.Mesh(innerGeo, matRed);
            innerMesh.receiveShadow = true; cupMesh.add(innerMesh);

            const rimPoints = [];
            rimPoints.push(new THREE.Vector2(rOpen - thickness - bevelSize, 0));
            rimPoints.push(new THREE.Vector2(rOpen - bevelSize, 0));
            rimPoints.push(new THREE.Vector2(rOpen - bevelSize, 0.01));
            rimPoints.push(new THREE.Vector2(rOpen - thickness - bevelSize, 0.01));
            rimPoints.push(new THREE.Vector2(rOpen - thickness - bevelSize, 0));
            const rimGeo = new THREE.LatheGeometry(rimPoints, 64);
            const rimMesh = new THREE.Mesh(rimGeo, matBlack); 
            rimMesh.castShadow = true; rimMesh.receiveShadow = true; cupMesh.add(rimMesh);

            cupMesh.position.set(CUP_TARGET_CLOSED.y, CUP_TARGET_CLOSED.y, CUP_TARGET_CLOSED.z);
            scene.add(cupMesh);
        }

        function updateSceneFromProgress(progress) {
            progress = Math.max(0, Math.min(1, progress));
            const ease = progress < 0.5 ? 2 * progress * progress : -1 + (4 - 2 * progress) * progress;
            let rotProgress = progress * 1.5; 
            if (rotProgress > 1) rotProgress = 1;
            const rotEase = 1 - Math.pow(1 - rotProgress, 3); 
            const posEase = ease;
            const tilt = Math.abs(CUP_TARGET_CLOSED.rotX + (CUP_TARGET_OPEN.rotX - CUP_TARGET_CLOSED.rotX) * rotEase);
            const sinkCorrection = Math.sin(tilt) * (CUP_RADIUS_OPEN * 0.9); 
            cupMesh.position.y = (CUP_TARGET_CLOSED.y + (CUP_TARGET_OPEN.y - CUP_TARGET_CLOSED.y) * posEase) + sinkCorrection;
            cupMesh.position.z = CUP_TARGET_CLOSED.z + (CUP_TARGET_OPEN.z - CUP_TARGET_CLOSED.z) * posEase;
            cupMesh.rotation.x = CUP_TARGET_CLOSED.rotX + (CUP_TARGET_OPEN.rotX - CUP_TARGET_CLOSED.rotX) * rotEase;
            const camX = CAM_POS_FAR.x + (CAM_POS_CLOSE.x - CAM_POS_FAR.x) * ease;
            const camY = CAM_POS_FAR.y + (CAM_POS_CLOSE.y - CAM_POS_FAR.y) * ease;
            const camZ = CAM_POS_FAR.z + (CAM_POS_CLOSE.z - CAM_POS_FAR.z) * ease;
            const lookX = LOOK_AT_FAR.x + (LOOK_AT_CLOSE.x - LOOK_AT_FAR.x) * ease;
            const lookY = LOOK_AT_FAR.y + (LOOK_AT_CLOSE.y - LOOK_AT_FAR.y) * ease;
            const lookZ = LOOK_AT_FAR.z + (LOOK_AT_CLOSE.z - LOOK_AT_FAR.z) * ease;
            currentCamPos.set(camX, camY, camZ);
            currentLookAt.set(lookX, lookY, lookZ);
            camera.position.copy(currentCamPos);
            camera.lookAt(currentLookAt);
        }

        function updateStatusText(text) {
            document.getElementById('status-text').innerText = text;
        }

        // [修改] 重写 shakeDice 函数，让动画更自然，且增加向镜头的倾斜和位移
        function shakeDice() {
            if (currentState !== GameState.IDLE) return;
            SoundManager.init();
            currentState = GameState.SHAKING;
            updateStatusText("摇动中...");
            
            // 每次摇动重置光效锁
            hasTriggeredJackpot = false;

            const startTime = Date.now();
            let lastShakeTime = 0; 
            
            // 使用 requestAnimationFrame 替代 setInterval，获得丝滑帧率
            const loop = () => {
                if (currentState !== GameState.SHAKING) return; // 防止状态冲突

                const elapsed = Date.now() - startTime;
                
                if (elapsed < SHAKE_DURATION) {
                    const t = elapsed * 0.025; 
                    
                    // 阻尼系数
                    let damping = 1.0;
                    const fadeOutTime = 250;
                    if (elapsed > SHAKE_DURATION - fadeOutTime) {
                        const remaining = SHAKE_DURATION - elapsed;
                        damping = remaining / fadeOutTime;
                        damping = damping * damping; 
                    }
                    
                    // 1. 主摇动
                    const swingX = Math.sin(t * 1.2) * 0.6 * damping;
                    
                    // 2. 垂直起伏
                    // [还原] 悬浮高度改回 0.8，防止穿模即可，不用抬太高
                    const baseLift = 0.8 * damping; 
                    // [还原] 移除 zOffset
                    
                    const bobY = Math.abs(Math.sin(t * 1.2)) * 0.4 * damping; 

                    // 3. 随机微颤
                    const noiseX = (Math.random() - 0.5) * 0.08 * damping;
                    const noiseY = (Math.random() - 0.5) * 0.08 * damping;
                    const noiseZ = (Math.random() - 0.5) * 0.08 * damping;

                    // 应用位置
                    cupMesh.position.x = swingX + noiseX;
                    // [还原] 基础高度
                    cupMesh.position.y = CUP_TARGET_CLOSED.y + baseLift + bobY + noiseY; 
                    // [还原] Z轴只保留微颤，不再前移
                    cupMesh.position.z = CUP_TARGET_CLOSED.z + noiseZ;

                    // 应用旋转
                    cupMesh.rotation.z = -swingX * 0.35; 
                    
                    // [还原] 移除 baseTiltX，不再刻意倾斜
                    cupMesh.rotation.x = (Math.random() - 0.5) * 0.1 * damping;
                    cupMesh.rotation.y = (Math.random() - 0.5) * 0.05 * damping;

                    // 声音触发
                    if (damping > 0.2 && elapsed - lastShakeTime > 100) {
                        if (Math.random() > 0.3) {
                            SoundManager.playShake(); 
                            lastShakeTime = elapsed;
                        }
                    }

                    // 内部骰子跟随
                    diceArray.forEach(dice => {
                        dice.rotation.x += Math.random() * 0.5 * damping;
                        dice.rotation.y += Math.random() * 0.5 * damping;
                        const range = CUP_RADIUS_OPEN * 0.4 * damping; 
                        
                        dice.position.x = cupMesh.position.x + (Math.random() - 0.5) * range;
                        // [还原] Z轴位置
                        dice.position.z = cupMesh.position.z + (Math.random() - 0.5) * range;
                        
                        // [还原] 骰子高度跟随
                        dice.position.y = DICE_SIZE / 2 + (Math.random() * 2.0 + 0.5) * damping; 
                    });
                    
                    requestAnimationFrame(loop);
                } else {
                    // 动画结束
                    finalizeDicePositions();
                    
                    // 强制复位
                    cupMesh.position.x = 0;
                    cupMesh.position.y = CUP_TARGET_CLOSED.y;
                    cupMesh.position.z = CUP_TARGET_CLOSED.z; 
                    cupMesh.rotation.x = 0; 
                    cupMesh.rotation.y = 0;
                    cupMesh.rotation.z = 0;
                    
                    updateSceneFromProgress(0); 
                    dragProgress = 0;
                    currentState = GameState.IDLE;
                    updateStatusText("向上滑动打开");
                }
            };
            
            loop();
        }

        function finalizeDicePositions() {
            const placedDice = [];
            const minDistance = DICE_SIZE * 1.15; 
            const snap = Math.PI / 2;
            currentDiceValues = []; 

            // 作弊逻辑：如果有作弊标识，预生成特定点数
            let riggedValues = null;
            if (isCheatActive && diceArray.length > 1) {
                // 生成作弊数组：N-1个相同，1个不同
                riggedValues = [];
                // 随机选一个主点数
                const mainVal = Math.floor(Math.random() * 6) + 1;
                // 随机选一个不同的点数
                let uniqueVal = Math.floor(Math.random() * 6) + 1;
                while(uniqueVal === mainVal) {
                    uniqueVal = Math.floor(Math.random() * 6) + 1;
                }
                // 填充主点数
                for (let i = 0; i < diceArray.length - 1; i++) {
                    riggedValues.push(mainVal);
                }
                // 插入不同点数
                riggedValues.push(uniqueVal);
                // 打乱顺序，让不同的那个不总是在同一个位置
                riggedValues.sort(() => Math.random() - 0.5);

                // 重置作弊状态
                isCheatActive = false;
                cheatClickCount = 0;
                clearTimeout(cheatClickTimer);
            }

            diceArray.forEach((dice, index) => {
                const value = riggedValues ? riggedValues[index] : (Math.floor(Math.random() * 6) + 1);
                currentDiceValues.push(value);
                dice.rotation.set(0, 0, 0); 
                switch(value) {
                    case 1: dice.rotateZ(Math.PI / 2); break;
                    case 6: dice.rotateZ(-Math.PI / 2); break;
                    case 2: break; 
                    case 5: dice.rotateX(Math.PI); break;
                    case 3: dice.rotateX(-Math.PI / 2); break;
                    case 4: dice.rotateX(Math.PI / 2); break;
                }
                dice.rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), Math.random() * Math.PI * 2);
                dice.position.y = DICE_SIZE / 2; 
                let position;
                let overlaps;
                let attempts = 0;
                const maxAttempts = 2000; 
                do {
                    overlaps = false;
                    const angle = Math.random() * Math.PI * 2;
                    const safeRadius = CUP_RADIUS_OPEN - 0.8; 
                    const r = Math.sqrt(Math.random()) * safeRadius;
                    position = new THREE.Vector3(Math.cos(angle) * r, dice.position.y, Math.sin(angle) * r);
                    for (const otherDice of placedDice) {
                        if (position.distanceTo(otherDice.position) < minDistance) {
                            overlaps = true; break;
                        }
                    }
                    attempts++;
                } while (overlaps && attempts < maxAttempts);
                dice.position.copy(position);
                placedDice.push(dice);
            });
        }

        function checkJackpot() {
            if (hasTriggeredJackpot) return;

            const totalDice = diceArray.length;
            
            // 规则：1, 2, 3 无论怎样都不出现光效
            if (totalDice <= 3) return;

            let threshold = 0;
            if (totalDice === 8) threshold = 5;       // 8颗骰子，>=5个相同触发
            else if (totalDice === 7) threshold = 4;  // 7颗骰子，>=4个相同触发
            else if (totalDice === 6) threshold = 4;  // 6颗骰子，>=4个相同触发
            else if (totalDice === 5) threshold = 3;  // 5颗骰子，>=3个相同触发
            else if (totalDice === 4) threshold = 3;  // 4颗骰子，>=3个相同触发

            if (threshold === 0) return;

            const counts = {};
            currentDiceValues.forEach(val => { counts[val] = (counts[val] || 0) + 1; });
            
            let hasJackpot = false;
            for (let val in counts) {
                if (counts[val] >= threshold) {
                    hasJackpot = true;
                    break;
                }
            }
            if (hasJackpot) {
                LightRayManager.trigger();
                hasTriggeredJackpot = true; 
            }
        }

        function snapAnimation(targetProgress) {
            if (isCupAnimating) return;
            isCupAnimating = true;
            
            const startProgress = dragProgress;
            let animProgress = 0;

            // 打开快，关闭稍慢（保留质感）
            const speed = (targetProgress === 1) ? 0.06 : 0.035;

            function loop() {
                animProgress += speed; 
                if (animProgress >= 1) {
                    dragProgress = targetProgress;
                    updateSceneFromProgress(targetProgress);
                    
                    if (targetProgress === 1) {
                        const isSettingsMode = document.getElementById('settings-panel').classList.contains('show');
                        
                        if (isSettingsMode) {
                            currentState = GameState.SETTINGS;
                        } else {
                            currentState = GameState.OPENED; 
                            updateStatusText("向下拖动盖上");
                            checkJackpot();
                            SoundManager.playOpen();
                        }
                    } else {
                        if (startProgress > 0.1) SoundManager.playClose();
                        
                        if (document.getElementById('game-panel').classList.contains('hidden')) {
                        } else {
                            currentState = GameState.IDLE; 
                            updateStatusText("点击骰盅摇骰子");
                        }
                    }
                    isCupAnimating = false;
                } else {
                    let ease;
                    if (targetProgress === 1) {
                        ease = 1 - Math.pow(1 - animProgress, 2); 
                    } else {
                        ease = 1 - Math.pow(1 - animProgress, 3);
                    }

                    const currentP = startProgress + (targetProgress - startProgress) * ease;
                    updateSceneFromProgress(currentP);
                    dragProgress = currentP;
                    requestAnimationFrame(loop);
                }
            }
            loop();
        }

        function onInputStart(e) {
            SoundManager.init();
            if (e.target.closest('button') || e.target.closest('.control-group')) return;
            if (currentState === GameState.SETTINGS) return;
            if (isCupAnimating || currentState === GameState.SHAKING) return;
            if (e.touches && e.touches.length > 1) return;
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            touchStartX = clientX; touchStartY = clientY; touchStartTime = Date.now();
            isInteracting = true; isDragging = false;
        }

        function onInputMove(e) {
            if (currentState === GameState.SETTINGS) return;
            if (!isInteracting) return; 
            if (isCupAnimating || currentState === GameState.SHAKING) return;
            e.preventDefault();
            let clientY;
            if (e.changedTouches) { if (e.changedTouches.length === 0) return; clientY = e.changedTouches[0].clientY; } else { clientY = e.clientY; }
            const diffY = clientY - touchStartY;
            if (!isDragging && Math.abs(diffY) > TAP_THRESHOLD) isDragging = true;
            if (isDragging) {
                let deltaProgress = -diffY / DRAG_FULL_DISTANCE;
                let baseProgress = (currentState === GameState.IDLE) ? 0 : 1;
                dragProgress = baseProgress + deltaProgress;
                updateSceneFromProgress(dragProgress);
            }
        }

        function onInputEnd(e) {
            if (currentState === GameState.SETTINGS) return;
            if (!isInteracting) return;
            isInteracting = false; 
            if (isCupAnimating || currentState === GameState.SHAKING) return;
            if (!isDragging) {
                const timeDiff = Date.now() - touchStartTime;
                if (timeDiff < 500) {
                    let clientX, clientY;
                    if (e.changedTouches) { clientX = e.changedTouches[0].clientX; clientY = e.changedTouches[0].clientY; } else { clientX = e.clientX; clientY = e.clientY; }
                    checkClick(clientX, clientY);
                }
                return;
            }
            isDragging = false;
            if (currentState === GameState.IDLE) {
                if (dragProgress > 0.3) snapAnimation(1); else snapAnimation(0); 
            } else { 
                if (dragProgress < 0.7) snapAnimation(0); else snapAnimation(1); 
            }
        }

        function checkClick(clientX, clientY) {
            if (currentState === GameState.IDLE) {
                mouse.x = (clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects([cupMesh], true);
                if (intersects.length > 0) shakeDice();
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            LightRayManager.animate();
            
            // 骰子动画
            diceArray.forEach(dice => {
                if (dice.userData.targetScale && dice.scale.x < dice.userData.targetScale) {
                    dice.userData.spawnTime += 0.05;
                    dice.scale.setScalar(Math.min(dice.scale.x + 0.1, 1));
                }
            });
            for (let i = dyingDiceArray.length - 1; i >= 0; i--) {
                const item = dyingDiceArray[i];
                item.scale -= 0.1; 
                if (item.scale <= 0) {
                    scene.remove(item.mesh);
                    item.mesh.geometry.dispose(); 
                    dyingDiceArray.splice(i, 1);
                } else {
                    item.mesh.scale.setScalar(item.scale);
                }
            }

            camera.lookAt(currentLookAt);
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>